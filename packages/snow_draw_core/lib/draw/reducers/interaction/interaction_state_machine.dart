import 'package:meta/meta.dart';

import '../../actions/draw_actions.dart';
import '../../core/draw_context.dart';
import '../../edit/core/edit_event_factory.dart';
import '../../edit/core/edit_modifiers.dart';
import '../../edit/core/edit_session_id_generator.dart';
import '../../edit/core/edit_session_service.dart';
import '../../models/draw_state.dart';
import '../camera/camera_reducer.dart';
import '../element/element_reducer.dart';
import '../selection/selection_reducer.dart';
import 'create/create_element_reducer.dart';
import 'edit/edit_state_reducer.dart';
import 'interaction_transition.dart';
import 'selection/box_select_reducer.dart';
import 'selection/pending_state_reducer.dart';
import 'text/text_edit_reducer.dart';

/// Interaction state machine - coordinates sub-reducers.
///
/// Responsibilities:
/// 1. Handle conflict-driven cancellation logic
/// 2. Dispatch actions to sub-reducers by priority
/// 3. Coordinate state transitions across subsystems
///
/// Only handles state transitions; events are generated by EventMiddleware
/// based on state changes.
@immutable
class InteractionStateMachine {
  const InteractionStateMachine();

  /// Single entry point for all interaction actions.
  InteractionTransition reduce({
    required DrawState state,
    required DrawAction action,
    required DrawContext context,
    required EditSessionService editSessionService,
    required EditSessionIdGenerator sessionIdGenerator,
    HistoryAvailability historyAvailability = const HistoryAvailability(),
    EditUpdateFailurePolicy updateFailurePolicy =
        EditUpdateFailurePolicy.toIdle,
  }) {
    var currentState = state;
    final events = <EditSessionEvent>[];
    final resolvedAction = _resolveEditIntentAction(action, context);
    if (resolvedAction == null) {
      return InteractionTransition.unchanged(currentState, events: events);
    }

    // 1) Conflict-driven cancellation.
    final editReducer = EditStateReducer(
      editSessionService: editSessionService,
      sessionIdGenerator: sessionIdGenerator,
      updateFailurePolicy: updateFailurePolicy,
    );

    final cancellation = handleCancellation(
      state: currentState,
      action: resolvedAction,
      editReducer: editReducer,
      historyAvailability: historyAvailability,
    );
    currentState = cancellation.state;
    if (cancellation.events.isNotEmpty) {
      events.addAll(cancellation.events);
    }

    // 2) Edit operations.
    final editResult = editReducer.reduce(
      state: currentState,
      action: resolvedAction,
      context: context,
    );
    if (editResult != null) {
      return InteractionTransition(
        nextState: editResult.nextState,
        events: [...events, ...editResult.events],
      );
    }

    // 3) Other interaction and domain reducers.
    final reduced = reduceState(currentState, resolvedAction, context);
    if (reduced != null) {
      return InteractionTransition(nextState: reduced, events: events);
    }

    return InteractionTransition.unchanged(currentState, events: events);
  }

  /// Handle non-edit actions (state only).
  ///
  /// ## Reducer Priority Order
  ///
  /// Reducers are called in a specific priority order. The first reducer that
  /// handles an action (returns non-null) wins, and subsequent reducers are
  /// skipped. This ordering ensures correct interaction semantics:
  ///
  /// 1. **Pending state** - Highest priority. Handles transient UI states like
  ///    hover and cursor changes. Must process first to ensure UI feedback is
  ///    immediate and not blocked by other interactions.
  ///
  /// 2. **Box selection** - Active selection gestures take priority over other
  ///    interactions. When the user is dragging a selection box, that gesture
  ///    should complete before other actions are considered.
  ///
  /// 3. **Element creation** - Creating new elements takes priority over
  ///    modifying existing ones. When in creation mode, pointer events should
  ///    be interpreted as drawing gestures, not selection or manipulation.
  ///
  /// 4. **Text editing** - Text input mode is modal and takes priority over
  ///    general selection/manipulation. Pointer events during text editing
  ///    should update the text cursor, not trigger element selection.
  ///
  /// 5. **Selection** - General selection logic (clicking elements, multi-select).
  ///    Runs after modal interactions but before element manipulation to ensure
  ///    selection state is updated before transforms are applied.
  ///
  /// 6. **Elements** - Element manipulation (move, resize, rotate). Runs after
  ///    selection is resolved so transforms apply to the correct selection set.
  ///
  /// 7. **Camera** - Lowest priority. Pan/zoom gestures only trigger if no
  ///    other interaction claimed the action. This allows element interactions
  ///    to take precedence over viewport navigation.
  ///
  /// ## Adding New Reducers
  ///
  /// When adding a new reducer, consider:
  /// - Is it a modal interaction (like text editing)? Place it before selection.
  /// - Does it manipulate existing elements? Place it after selection.
  /// - Is it a fallback behavior? Place it near the end (before camera).
  /// - Does it need to override all other interactions? Place it first.
  DrawState? reduceState(
    DrawState state,
    DrawAction action,
    DrawContext context,
  ) {
    // 1. Pending state (hover, cursor changes).
    const pendingReducer = PendingStateReducer();
    final pendingResult = pendingReducer.reduce(state, action);
    if (pendingResult != null) {
      return pendingResult;
    }

    // 2. Box selection (active selection gestures).
    const boxSelectReducer = BoxSelectReducer();
    final boxSelectResult = boxSelectReducer.reduce(state, action);
    if (boxSelectResult != null) {
      return boxSelectResult;
    }

    // 3. Element creation (drawing new elements).
    const createReducer = CreateElementReducer();
    final createResult = createReducer.reduce(state, action, context);
    if (createResult != null) {
      return createResult;
    }

    // 4. Text editing (modal text input).
    const textEditReducer = TextEditReducer();
    final textResult = textEditReducer.reduce(state, action, context);
    if (textResult != null) {
      return textResult;
    }

    // 5. Selection (click to select, multi-select).
    final selectionResult = selectionReducer(state, action, context);
    if (selectionResult != null) {
      return selectionResult;
    }

    // 6. Elements (move, resize, rotate).
    final elementResult = elementReducer(state, action, context);
    if (elementResult != null) {
      return elementResult;
    }

    // 7. Camera (pan, zoom - fallback behavior).
    final cameraResult = cameraReducer(state, action, context);
    if (cameraResult != null) {
      return cameraResult;
    }

    return null;
  }

  /// Pre-reducer stabilization.
  DrawState stabilize(DrawState state, DrawAction action, DrawContext _) {
    if (state.application.isEditing && action.conflictsWithEditing) {
      return state.copyWith(application: state.application.toIdle());
    }
    return state;
  }
}

@immutable
class CancellationResult {
  const CancellationResult({required this.state, this.events = const []});
  final DrawState state;
  final List<EditSessionEvent> events;
}

extension InteractionStateMachineCancellation on InteractionStateMachine {
  @visibleForTesting
  CancellationResult handleCancellation({
    required DrawState state,
    required DrawAction action,
    required EditStateReducer editReducer,
    required HistoryAvailability historyAvailability,
  }) {
    if (!state.application.isEditing) {
      return CancellationResult(state: state);
    }

    if (!action.conflictsWithEditing &&
        !historyAvailability.shouldCancelFor(action)) {
      return CancellationResult(state: state);
    }

    final cancel = editReducer.cancelIfEditingOutcome(state);
    if (cancel == null) {
      return CancellationResult(state: state);
    }

    final cancelEvent = cancel.isSuccess
        ? EditCancelled(operationId: cancel.operationId)
        : EditCancelFailed(
            reason: cancel.failureReason!,
            operationId: cancel.operationId,
          );

    return CancellationResult(state: cancel.state, events: [cancelEvent]);
  }
}

const interactionStateMachine = InteractionStateMachine();

@immutable
class HistoryAvailability {
  const HistoryAvailability({this.canUndo = true, this.canRedo = true});
  final bool canUndo;
  final bool canRedo;

  bool shouldCancelFor(DrawAction action) {
    if (action is Undo) {
      return canUndo;
    }
    if (action is Redo) {
      return canRedo;
    }
    return false;
  }
}

DrawAction? _resolveEditIntentAction(DrawAction action, DrawContext context) {
  if (action is! EditIntentAction) {
    return action;
  }
  return context.editIntentMapper.mapToStartEdit(
    intent: action.intent,
    position: action.position,
    modifiers: action.modifiers,
    editOperations: context.editOperations,
  );
}
