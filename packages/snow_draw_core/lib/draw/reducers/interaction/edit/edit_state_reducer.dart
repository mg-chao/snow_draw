import 'package:meta/meta.dart';

import '../../../actions/draw_actions.dart';
import '../../../core/draw_context.dart';
import '../../../edit/core/edit_event_factory.dart';
import '../../../edit/core/edit_modifiers.dart';
import '../../../edit/core/edit_param_injector.dart';
import '../../../edit/core/edit_result_unified.dart';
import '../../../edit/core/edit_session_id_generator.dart';
import '../../../edit/core/edit_session_service.dart';
import '../../../models/draw_state.dart';
import '../interaction_transition.dart';

/// Reducer dedicated to edit operations.
///
/// Handles: StartEdit, UpdateEdit, FinishEdit, CancelEdit.
/// Only handles state transitions; events are generated by EventMiddleware
/// based on state changes.
@immutable
class EditStateReducer {
  const EditStateReducer({
    required this.editSessionService,
    required this.sessionIdGenerator,
    this.updateFailurePolicy = EditUpdateFailurePolicy.toIdle,
    this.eventFactory = const EditEventFactory(),
  });
  final EditSessionService editSessionService;
  final EditSessionIdGenerator sessionIdGenerator;
  final EditUpdateFailurePolicy updateFailurePolicy;
  final EditEventFactory eventFactory;

  /// Try to handle edit-related actions.
  ///
  /// Returns null if the action is not an edit action.
  InteractionTransition? reduce({
    required DrawState state,
    required DrawAction action,
    required DrawContext context,
  }) => switch (action) {
    final StartEdit a => _reduceStartEdit(
      action: a,
      state: state,
      context: context,
    ),
    final UpdateEdit a => _reduceUpdateEdit(action: a, state: state),
    FinishEdit _ => _reduceFinishEdit(state: state),
    CancelEdit _ => _reduceCancelEdit(state: state),
    _ => null,
  };

  /// Cancel the current edit (if editing).
  ///
  /// Used during conflict handling.
  DrawState cancelIfEditing(DrawState state) {
    final outcome = cancelIfEditingOutcome(state);
    return outcome?.state ?? state;
  }

  EditResult? cancelIfEditingOutcome(DrawState state) {
    if (!state.application.isEditing) {
      return null;
    }
    return editSessionService.cancel(state: state);
  }

  InteractionTransition _reduceStartEdit({
    required StartEdit action,
    required DrawState state,
    required DrawContext context,
  }) {
    var currentState = state;
    final events = <EditSessionEvent>[];

    // When starting a new edit, cancel the current edit first.
    if (currentState.application.isEditing) {
      final cancel = cancelIfEditingOutcome(currentState);
      if (cancel != null) {
        currentState = cancel.state;
        events.add(eventFactory.forCancelResult(cancel));
      }
    }

    // Use the current EditConfigProvider.
    final injector = EditParamInjector.fromProvider(context.editConfigProvider);
    final sessionId = sessionIdGenerator();
    final start = editSessionService.start(
      state: currentState,
      operationId: action.operationId,
      position: action.position,
      params: action.params,
      paramInjector: injector,
      sessionId: sessionId,
    );

    final startEvent = eventFactory.forStartResult(start, action.operationId);
    if (startEvent != null) {
      events.add(startEvent);
    }

    return InteractionTransition(nextState: start.state, events: events);
  }

  InteractionTransition _reduceUpdateEdit({
    required UpdateEdit action,
    required DrawState state,
  }) {
    final update = editSessionService.update(
      state: state,
      currentPosition: action.currentPosition,
      modifiers: action.modifiers,
      failurePolicy: updateFailurePolicy,
    );

    final updateEvent = eventFactory.forUpdateResult(update);
    return InteractionTransition(
      nextState: update.state,
      events: updateEvent == null ? const [] : [updateEvent],
    );
  }

  InteractionTransition _reduceFinishEdit({required DrawState state}) {
    final finish = editSessionService.finish(state: state);
    final finishEvent = eventFactory.forFinishResult(finish);
    return InteractionTransition(
      nextState: finish.state,
      events: finishEvent == null ? const [] : [finishEvent],
    );
  }

  InteractionTransition _reduceCancelEdit({required DrawState state}) {
    final cancel = editSessionService.cancel(state: state);
    return InteractionTransition(
      nextState: cancel.state,
      events: [eventFactory.forCancelResult(cancel)],
    );
  }
}
