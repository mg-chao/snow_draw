# Elbow Arrow Fixed Segments - Product Requirements Document

## 1. Overview

### 1.1 Purpose

This document specifies the functional requirements for implementing fixed segments in elbow (orthogonal) arrows. Elbow arrows are connectors that only use horizontal and vertical line segments, forming right-angle turns. Fixed segments allow users to manually control specific portions of an arrow's path while letting the system automatically route the remaining portions.

### 1.2 Scope

This PRD covers:
- Data model for fixed segments
- Segment classification (fixed vs. free)
- User interactions for creating, modifying, and releasing fixed segments
- System behavior for various operations involving fixed segments
- Constraints and validation rules
- Edge cases and special handling

---

## 2. Core Concepts

### 2.1 Elbow Arrow Structure

An elbow arrow consists of:
- **Points**: An ordered array of coordinates defining the arrow path
- **Segments**: Line segments connecting consecutive points (segment N connects point N-1 to point N)
- **Start Point**: The first point (index 0)
- **End Point**: The last point (index = points.length - 1)

```
Points:     P0 -------- P1 -------- P2 -------- P3
Segments:      Seg 1       Seg 2       Seg 3
              (idx=1)     (idx=2)     (idx=3)
```

### 2.2 Segment Types

#### 2.2.1 Free Segments
- Automatically generated by the routing algorithm
- Can be completely recalculated when endpoints move or conditions change
- No user-defined position constraints

#### 2.2.2 Fixed Segments
- User-controlled segments with locked positions
- Created when user drags a segment's midpoint
- Maintain their axis-aligned position during certain operations
- Store both coordinates and segment index

### 2.3 Segment Indexing

- Segment index starts at 1 (segment 1 connects point 0 to point 1)
- Segment index N corresponds to the segment from point[N-1] to point[N]
- Maximum segment index = points.length - 1

---

## 3. Data Model

### 3.1 Fixed Segment Structure

```typescript
interface FixedSegment {
  start: Point;    // Start point coordinates (local to arrow origin)
  end: Point;      // End point coordinates (local to arrow origin)
  index: number;   // Segment index in the points array
}
```

### 3.2 Arrow State

```typescript
interface ElbowArrow {
  x: number;                           // Arrow origin X
  y: number;                           // Arrow origin Y
  points: Point[];                     // Array of points (local coordinates)
  fixedSegments: FixedSegment[] | null; // Array of fixed segments, sorted by index
  startBinding: Binding | null;        // Connection to start element
  endBinding: Binding | null;          // Connection to end element
  startIsSpecial: boolean | null;      // Special handling flag for start
  endIsSpecial: boolean | null;        // Special handling flag for end
}
```

### 3.3 Coordinate System

- All fixed segment coordinates are stored in **local space** (relative to arrow origin)
- Arrow origin (x, y) is always the first point's global position
- Global position = Arrow origin + Local position

---

## 4. Constraints and Validation Rules

### 4.1 Segment Orientation

**Rule**: All segments in an elbow arrow MUST be either horizontal or vertical.

- Horizontal: `start.y === end.y`
- Vertical: `start.x === end.x`

**Validation**: Any attempt to create a diagonal fixed segment MUST be rejected.

### 4.2 First and Last Segment Restrictions

**Rule**: The first segment (index = 1) and last segment (index = points.length - 1) CANNOT be marked as fixed.

**Rationale**: These segments connect to endpoints that may be bound to external elements. Their positions are determined by binding logic and exit direction requirements.

### 4.3 Segment Count Preservation

**Rule**: When fixed segments exist, the arrow MUST maintain the same number of segments during endpoint drag operations.

**Rationale**: Fixed segments act as anchors in the path structure. Adding or removing segments would invalidate the fixed segment indices.

### 4.4 Alternating Direction

**Rule**: Consecutive segments MUST alternate between horizontal and vertical.

**Rationale**: This is fundamental to elbow arrow geometry - two consecutive horizontal or vertical segments should be merged into one.

---

## 5. User Operations

### 5.1 Creating a Fixed Segment

**Trigger**: User drags a segment's midpoint handle

**Behavior**:
1. Identify the segment being dragged by its index
2. Determine if segment is horizontal or vertical
3. Calculate new segment position based on drag direction:
   - Horizontal segment: Move along Y axis only
   - Vertical segment: Move along X axis only
4. Create FixedSegment entry with new coordinates and index
5. Add to fixedSegments array (maintain sorted order by index)
6. Recalculate adjacent free segments to connect to the new position

**Constraints**:
- Cannot fix first segment (index = 1) when bound to start element
- Cannot fix last segment when bound to end element

### 5.2 Path Consistency When Fixing a Segment

A critical requirement is ensuring the arrow path remains visually unchanged when a segment is first fixed (before any drag movement occurs).

#### 5.2.1 The Consistency Challenge

When a user clicks on a segment's midpoint to begin fixing it:
- The hit detection has a tolerance area (user doesn't need to click exactly on the line)
- The click position may differ slightly from the segment's actual position
- Without proper handling, the segment could "jump" to the click position

#### 5.2.2 Coordinate Preservation Strategy

For elbow arrows, segments are either horizontal or vertical. The coordinate preservation works as follows:

**For Horizontal Segments** (constant Y):
- **Preserved**: X coordinates of start and end points (taken from existing points)
- **Potentially modified**: Y coordinate (based on interaction position)

**For Vertical Segments** (constant X):
- **Preserved**: Y coordinates of start and end points (taken from existing points)
- **Potentially modified**: X coordinate (based on interaction position)

```
Fixed Segment Coordinate Calculation:

If segment is HORIZONTAL:
  start.x = existingPoints[index - 1].x  ← Preserved from original
  start.y = interactionPosition.y         ← From mouse/touch position
  end.x   = existingPoints[index].x       ← Preserved from original
  end.y   = interactionPosition.y         ← From mouse/touch position

If segment is VERTICAL:
  start.x = interactionPosition.x         ← From mouse/touch position
  start.y = existingPoints[index - 1].y   ← Preserved from original
  end.x   = interactionPosition.x         ← From mouse/touch position
  end.y   = existingPoints[index].y       ← Preserved from original
```

#### 5.2.3 Ensuring True Consistency (Recommended Approach)

To guarantee the path looks identical before and after fixing:

**Option A: Use Segment's True Position**
- When first creating a fixed segment (initial click without drag)
- Use the segment's actual midpoint coordinates, not the click position
- Only use interaction position after drag movement begins

**Option B: Snap to Original**
- Calculate the segment's true position before fixing
- If the click position is within a threshold of the original, snap to original
- This prevents micro-jumps from imprecise clicks

**Option C: Two-Phase Fixing**
1. **Phase 1 (Click)**: Mark segment as "pending fix" without changing position
2. **Phase 2 (Drag)**: Apply position change based on drag delta from original position

#### 5.2.4 Implementation Pseudocode

```
function createFixedSegment(segment, clickPosition, existingPoints):
    isHorizontal = segment.isHorizontal()
    
    // Calculate true segment position
    truePosition = calculateSegmentMidpoint(existingPoints, segment.index)
    
    // Option A: Always use true position for initial fix
    if isFirstClick:
        movingAxisValue = isHorizontal 
            ? truePosition.y 
            : truePosition.x
    else:
        movingAxisValue = isHorizontal 
            ? clickPosition.y 
            : clickPosition.x
    
    // Non-moving axis always from existing points (guaranteed consistent)
    fixedSegment = {
        index: segment.index,
        start: {
            x: isHorizontal ? existingPoints[index-1].x : movingAxisValue,
            y: isHorizontal ? movingAxisValue : existingPoints[index-1].y
        },
        end: {
            x: isHorizontal ? existingPoints[index].x : movingAxisValue,
            y: isHorizontal ? movingAxisValue : existingPoints[index].y
        }
    }
    
    return fixedSegment
```

#### 5.2.5 Consistency Verification

After fixing a segment, verify:
1. Total number of points unchanged
2. All point coordinates unchanged (within floating-point tolerance)
3. All segment indices unchanged
4. Visual rendering identical

#### 5.2.6 Path Consistency for Bound Arrows

When an arrow is bound to elements, additional considerations apply:

**Bound Arrow Structure**:
```
    Element A                                    Element B
    ┌─────────┐                                 ┌─────────┐
    │         ●━━━━●━━━━━━●━━━━━━●━━━━●         │         │
    │         │ P0  P1    P2     P3   P4       │         │
    └─────────┘  ↑                      ↑       └─────────┘
              Exit segment         Entry segment
              (controlled by       (controlled by
               binding)             binding)
```

**Key Constraints for Bound Arrows**:

1. **First and last segments are NOT fixable**
   - Exit segment (index 1): Controlled by start binding, exit direction, and BASE_PADDING
   - Entry segment (last index): Controlled by end binding, entry direction, and BASE_PADDING
   - Only middle segments (index 2 to points.length - 2) can be fixed

2. **Exit/Entry directions affect segment structure**
   - The binding determines which side of the element the arrow exits/enters
   - This affects the heading (UP, DOWN, LEFT, RIGHT) of adjacent segments
   - Middle segments must maintain perpendicularity with exit/entry segments

3. **Consistency requirements**:
   - When fixing a middle segment on a bound arrow, the exit/entry segments MUST remain unchanged
   - The fixed segment's coordinates should come from the existing points (which already account for binding)
   - Fixing a segment should NOT trigger re-routing of exit/entry segments

**Bound Arrow Fixing Flow**:

```
1. User clicks on middle segment (e.g., segment 2 or 3)
2. Validate: index > 1 AND index < points.length - 1
3. Calculate fixed segment coordinates FROM EXISTING POINTS:
   - start = points[index - 1]  ← Already positioned by prior routing
   - end = points[index]        ← Already positioned by prior routing
4. Store as fixed segment
5. Exit/entry segments remain exactly as they were
```

**Why Bound Arrows Have Implicit Consistency**:

For bound arrows, the middle segments' positions are already determined by:
- The exit heading from the start element
- The entry heading to the end element  
- The routing algorithm that created the path

When you fix a middle segment, you're capturing its **current** position, which is already consistent with the bound structure. The key is to use the existing point coordinates, not the mouse click position.

**Edge Case - Binding Changes After Fixing**:

When an element moves or the binding point changes after segments are fixed:

```
Before element move:          After element move:
    ┌─────────┐               ┌─────────┐
    │    ●━━━━│━●             │         ●━━━●
    └─────────┘ │             └─────────┘   │
          ■━━━━━■ FIXED             ■━━━━━━━■ FIXED (preserved)
                │                          │
                ●                          ●
```

- Fixed segment's **perpendicular position** is preserved
- Exit/entry segments are recalculated to connect to the fixed segment
- The fixed segment acts as an anchor point in the path

**Special Point Handling with Binding**:

When an arrow with fixed segments has its bound element moved such that the exit direction changes:

```
Horizontal exit → Vertical exit:
    
Before:                    After:
┌─────┐                    ┌─────┐
│     ●━━━●                │  ●  │
└─────┘   │                └──│──┘
    ■━━━━━■ FIXED             │
          │                   ●━━━●  ← Extra segment added
          ●                   ■━━━━━■ FIXED (index adjusted!)
                                   │
                                   ●
```

- `startIsSpecial` or `endIsSpecial` flags are set
- Fixed segment indices are adjusted (+1 or -1)
- The fixed segment's position is preserved, but its index changes

### 5.3 Moving an Existing Fixed Segment

**Trigger**: User drags a previously fixed segment's midpoint

**Behavior**:
1. Detect which fixed segment is being moved (compare with stored positions)
2. Update the segment's start and end coordinates
3. Adjust neighboring segments to maintain connectivity:
   - Previous segment's end point aligns with moved segment's start
   - Next segment's start point aligns with moved segment's end
4. If neighboring segment is also fixed, update its coordinates accordingly

**Special Case - First Segment (Bound to Start Element)**:
- If segment becomes too short (< minimum threshold), use adaptive padding
- Padding = segmentLength / 2 (instead of standard padding)

**Special Case - Last Segment (Bound to End Element)**:
- Same adaptive padding logic as first segment

### 5.4 Releasing a Fixed Segment

**Trigger**: User explicitly unfixes a segment (e.g., double-click or context menu)

**Behavior**:
1. Remove the segment from fixedSegments array
2. Identify the region to re-route:
   - Start: Previous fixed segment's end (or arrow start if none)
   - End: Next fixed segment's start (or arrow end if none)
3. Run routing algorithm on this sub-path
4. Splice the new route into the existing points array
5. Update indices of remaining fixed segments if point count changed

#### 5.4.1 Path Consistency on Release

When releasing a fixed segment, the path will likely change because:
- The routing algorithm generates an "optimal" path
- The fixed segment's position may not be on the optimal path
- The number of segments in the released region may change

**This is expected behavior** - releasing a segment returns control to the automatic router.

**Consistency considerations**:
- Fixed segments that remain should NOT change position
- Only the released region should be re-routed
- If the released segment was on the optimal path, the visual result may be identical

### 5.5 Dragging Endpoints

**Trigger**: User drags the start or end point of the arrow

**When NO fixed segments exist**:
- Run full routing algorithm to regenerate entire path

**When fixed segments exist**:

1. **Preserve segment count**: The arrow maintains the exact number of segments
2. **Translate fixed segments**: Fixed segment positions are translated relative to new start point
3. **Recalculate connection points**: 
   - The points adjacent to fixed segments are recalculated
   - One coordinate comes from the moved endpoint
   - Other coordinate maintains connection to fixed segment
4. **Fixed segment endpoints are recalculated**: 
   - `fixedSegment.start = newPoints[index - 1]`
   - `fixedSegment.end = newPoints[index]`

**Critical Insight**: Fixed segments do NOT preserve their absolute length during endpoint drag. The segment's position along its perpendicular axis is preserved, but the connection points (and thus length) are recalculated from the regenerated points array.

#### 5.5.1 What IS Preserved During Endpoint Drag

| Property | Preserved? | Notes |
|----------|------------|-------|
| Segment count | Yes | Structure is locked |
| Segment index | Yes | Position in path maintained |
| Perpendicular position | Yes | The axis perpendicular to segment direction |
| Segment length | **No** | Connection points recalculated |
| Segment direction | Yes | Horizontal stays horizontal, vertical stays vertical |

#### 5.5.2 Why Length Changes

The free segments connecting endpoints to fixed segments must maintain perpendicularity:

```
Before endpoint drag:
    Start ●━━━━━━━● A
                  │
            Fixed ■━━━━━━■ B (length = 100)
                        │
                   ●━━━━● End

After dragging Start up by 30px:
    Start ●━━━━━━━━━━━━━● A'  ← A' recalculated to connect
                        │
            Fixed ■━━━━━■ B'  ← B' = A', so length changed!
                       │
                  ●━━━━● End

The fixed segment's Y position is preserved,
but its length changed from 100 to 70.
```

### 5.6 Resizing the Arrow

**Trigger**: User resizes the arrow using transform handles

**Behavior**:
- Both points and fixedSegments are provided in the update
- Apply the resize transformation directly
- No re-routing is performed

---

## 6. Routing Algorithm Integration

### 6.1 Full Routing (No Fixed Segments)

When `fixedSegments` is empty or null:
1. Calculate dynamic bounding boxes for start/end elements (if bound)
2. Generate a grid of possible path nodes
3. Use A* pathfinding from start dongle to end dongle
4. Apply penalties for direction changes (to prefer straighter paths)
5. Remove short segments (below threshold)
6. Return optimized path

### 6.2 Partial Routing (With Fixed Segments)

When modifying arrows with fixed segments:
1. Identify free regions (segments between fixed segments or between endpoints and fixed segments)
2. For each free region, run routing algorithm independently
3. Splice results together, maintaining fixed segment positions

### 6.3 Re-normalization

**Trigger**: Scene changes, element movements, or binding updates

**Process**:
1. Iterate through points, checking for:
   - Parallel consecutive segments (same direction) → merge them
   - Segments too short (< threshold) → remove and merge adjacent
2. Update fixed segment indices when points are removed
3. Update fixed segment coordinates when merge affects them
4. If all fixed segments become invalid, revert to full routing

---

## 7. Special Point Handling

### 7.1 Purpose

When an arrow with fixed segments is bound to an element, and the element's position causes the arrow to need an extra segment at the start or end, "special point" flags are used.

### 7.2 startIsSpecial / endIsSpecial Flags

**When TRUE**:
- An extra point exists at the start/end of the arrow
- The 3rd point (instead of 2nd) is used as the visual second point
- This allows maintaining the point structure while adapting to binding direction changes

**When FALSE**:
- Normal point indexing is used
- 2nd point is the visual second point

### 7.3 Index Adjustment

When special point status changes:
- If `startIsSpecial` becomes true: increment all fixed segment indices > 1 by 1
- If `startIsSpecial` becomes false: decrement all fixed segment indices > 1 by 1

---

## 8. Edge Cases

### 8.1 Segment Too Short

**Threshold**: Minimum segment length (e.g., 45 pixels = BASE_PADDING + 5)

**Handling**:
- When a fixed segment becomes shorter than the threshold during operations
- Use adaptive padding: `padding = segmentLength / 2` instead of standard padding
- Prevents visual artifacts and maintains valid geometry

### 8.2 Deduplication

**Threshold**: Very short segments (e.g., < 1 pixel)

**Handling**:
- Remove segments shorter than deduplication threshold
- Merge adjacent segments
- Update fixed segment indices accordingly

### 8.3 Collinear Points

When three consecutive points become collinear:
1. Remove the middle point
2. If middle segment was fixed, remove from fixedSegments
3. If adjacent segment was fixed, update its coordinates
4. Decrement indices of all subsequent fixed segments

### 8.4 All Fixed Segments Invalidated

When re-normalization removes all valid fixed segments:
- Clear fixedSegments (set to null)
- Run full routing algorithm
- Arrow returns to fully automatic routing

### 8.5 Boundary Limits

**Maximum Position**: Coordinates should be clamped to reasonable bounds (e.g., ±1,000,000)

**Validation**: Log warning if arrow extends beyond reasonable bounds

---

## 9. State Transitions

### 9.1 Arrow States

```
┌─────────────────┐
│   FULLY AUTO    │ ← Initial state, no fixed segments
│  (free routing) │
└────────┬────────┘
         │ User fixes a segment
         ▼
┌─────────────────┐
│  PARTIALLY FIXED │ ← Some segments fixed, others auto-routed
│   (hybrid mode)  │
└────────┬────────┘
         │ User fixes more segments
         ▼
┌─────────────────┐
│  MOSTLY FIXED   │ ← Most/all middle segments fixed
│ (minimal auto)  │
└─────────────────┘
```

### 9.2 Transition Triggers

| From | To | Trigger |
|------|-----|---------|
| FULLY AUTO | PARTIALLY FIXED | First segment fixed |
| PARTIALLY FIXED | FULLY AUTO | All fixed segments released or invalidated |
| PARTIALLY FIXED | MOSTLY FIXED | Additional segments fixed |
| MOSTLY FIXED | PARTIALLY FIXED | Some segments released |

---

## 10. Operation Decision Matrix

| Operation | Fixed Segments Exist | Behavior |
|-----------|---------------------|----------|
| Endpoint drag | No | Full re-route |
| Endpoint drag | Yes | Preserve structure, recalculate connections |
| Segment midpoint drag (new) | N/A | Create fixed segment |
| Segment midpoint drag (existing) | Yes | Update fixed segment position |
| Release segment | Yes | Re-route affected region |
| Element binding change | Either | Re-normalize, update special flags |
| Resize | Either | Apply transform directly |

---

## 11. Algorithm Pseudocode

### 11.1 Main Update Entry Point

```
function updateElbowArrowPoints(arrow, updates):
    // Case 1: Re-normalization (no explicit updates)
    if no updates provided:
        return handleRenormalization(arrow)
    
    // Case 2: No fixed segments - full routing
    if fixedSegments is empty:
        return routeElbowArrow(arrow, updates)
    
    // Case 3: Segment release
    if fixedSegments count decreased:
        return handleSegmentRelease(arrow, fixedSegments)
    
    // Case 4: Manual segment move (no point updates)
    if no point updates:
        return handleSegmentMove(arrow, fixedSegments)
    
    // Case 5: Resize (both points and fixedSegments provided)
    if points and fixedSegments both provided:
        return updates directly
    
    // Case 6: Endpoint drag with fixed segments
    return handleEndpointDrag(arrow, points, fixedSegments)
```

### 11.2 Handle Endpoint Drag

```
function handleEndpointDrag(arrow, newEndpoints, fixedSegments):
    // Translate fixed segments relative to new start
    translatedFixed = fixedSegments.map(segment => 
        translate(segment, arrow.origin, newEndpoints[0]))
    
    // Build new points array maintaining structure
    newPoints = []
    
    // Calculate start connection (free segment)
    secondPoint = calculateConnectionPoint(
        startEndpoint, 
        existingSecondPoint, 
        startHeading
    )
    newPoints.push(startEndpoint, secondPoint)
    
    // Add middle points (preserve existing)
    for each middle point:
        newPoints.push(point)
    
    // Calculate end connection (free segment)
    secondToLastPoint = calculateConnectionPoint(
        endEndpoint,
        existingSecondToLastPoint,
        endHeading
    )
    newPoints.push(secondToLastPoint, endEndpoint)
    
    // Recalculate fixed segment coordinates from new points
    for each fixedSegment:
        fixedSegment.start = newPoints[index - 1]
        fixedSegment.end = newPoints[index]
    
    return { points: newPoints, fixedSegments }
```

### 11.3 Handle Segment Move

```
function handleSegmentMove(arrow, fixedSegments):
    // Find actively modified segment
    modifiedSegment = findModifiedSegment(arrow.fixedSegments, fixedSegments)
    
    // Clone existing points
    newPoints = clone(arrow.points)
    
    // Apply fixed segment position to points
    newPoints[modifiedSegment.index - 1] = modifiedSegment.start
    newPoints[modifiedSegment.index] = modifiedSegment.end
    
    // Adjust neighboring points for connectivity
    if previousSegment exists:
        alignPreviousSegment(newPoints, modifiedSegment)
    if nextSegment exists:
        alignNextSegment(newPoints, modifiedSegment)
    
    // Handle first/last segment special cases
    if isFirstSegment and boundToElement:
        insertExitSegment(newPoints, startHeading)
        incrementFixedSegmentIndices()
    
    if isLastSegment and boundToElement:
        insertEntrySegment(newPoints, endHeading)
    
    return { points: newPoints, fixedSegments }
```

---

## 12. Constants and Configuration

| Constant | Value | Description |
|----------|-------|-------------|
| BASE_PADDING | 40 | Minimum exit segment length from bound elements |
| DEDUP_THRESHOLD | 1 | Minimum segment length before removal |
| SHORT_SEGMENT_THRESHOLD | 45 | Threshold for adaptive padding |
| MAX_POSITION | 1,000,000 | Maximum coordinate value |

---

## 13. Testing Scenarios

### 13.1 Basic Operations
- [ ] Create fixed segment on middle segment
- [ ] Move fixed segment horizontally
- [ ] Move fixed segment vertically
- [ ] Release fixed segment

### 13.2 Endpoint Operations
- [ ] Drag start endpoint with one fixed segment
- [ ] Drag end endpoint with one fixed segment
- [ ] Drag endpoint with multiple fixed segments
- [ ] Drag endpoint causing special point activation

### 13.3 Binding Scenarios
- [ ] Fix segment, then bind start to element
- [ ] Fix segment, then bind end to element
- [ ] Move bound element with fixed segments
- [ ] Unbind element with fixed segments

### 13.4 Edge Cases
- [ ] Fix segment that becomes too short
- [ ] Create collinear points through fixed segment
- [ ] Invalidate all fixed segments through element movement
- [ ] Resize arrow with fixed segments

### 13.5 Multi-Segment
- [ ] Fix two non-adjacent segments
- [ ] Fix two adjacent segments
- [ ] Move one fixed segment affecting another
- [ ] Release middle fixed segment with others remaining

---

## 14. Glossary

| Term | Definition |
|------|------------|
| **Elbow Arrow** | A connector using only horizontal and vertical segments |
| **Fixed Segment** | A user-controlled segment with locked perpendicular position |
| **Free Segment** | An automatically routed segment |
| **Dongle** | Exit/entry point from bound element's bounding box |
| **Special Point** | Hidden point maintaining structure during binding transitions |
| **Local Coordinates** | Coordinates relative to arrow origin |
| **Global Coordinates** | Absolute canvas coordinates |
| **Segment Index** | 1-based index identifying segment position in path |

---

## 15. Version History

| Version | Date | Changes |
|---------|------|---------|
| 1.0 | 2026-01-30 | Initial PRD based on Excalidraw implementation analysis |
